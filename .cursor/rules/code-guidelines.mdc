---
description: Mucaro Stack - Comprehensive Development Guidelines
globs: "**/*.{ts,tsx,js,jsx,sql,json,md,mdx}"
alwaysApply: true
---

# Mucaro Stack Development Guidelines

A comprehensive guide for developing with Next.js, Clerk Auth, Drizzle ORM, PostgreSQL, Tailwind CSS, and Biome in a monorepo architecture.

## üö® CRITICAL ARCHITECTURE RULES

**BEFORE writing any code, remember:**

1. **Apps NEVER import external dependencies directly** if workspace packages exist
2. **Always check workspace packages first** - extend them instead of bypassing them  
3. **Follow the decision tree**: Auth ‚Üí `@workspace/auth`, DB ‚Üí `@workspace/db`, UI ‚Üí `@workspace/ui`
4. **Architecture over speed** - proper abstractions prevent technical debt

**Quick Check**: If you're about to `pnpm add` an external package to an app, STOP and check if a workspace package should handle it instead.

## Tech Stack Overview

- **Frontend**: Next.js 15+ with App Router, React 19, Tailwind CSS 4
- **Authentication**: Clerk with OAuth, SSO, and session management  
- **Database**: PostgreSQL with Drizzle ORM and Drizzle Kit migrations
- **Styling**: Tailwind CSS 4 with utility classes only
- **Tooling**: Biome for formatting/linting, TypeScript, pnpm workspaces
- **Monorepo**: Turborepo with workspace packages

## Package Architecture

### Workspace Packages

```
packages/
‚îú‚îÄ‚îÄ auth/          # @workspace/auth - Clerk authentication integration
‚îú‚îÄ‚îÄ db/            # @workspace/db - Database schema and connections  
‚îú‚îÄ‚îÄ ui/            # @workspace/ui - Shared UI components
‚îî‚îÄ‚îÄ typescript-config/ # @workspace/typescript-config - Shared TS configs
```

### Apps

```
apps/
‚îî‚îÄ‚îÄ web/           # Next.js application
```

## CRITICAL: Monorepo Architecture Principles

### **NEVER bypass workspace packages for direct external dependencies**

**FUNDAMENTAL RULE**: Apps should NEVER install external dependencies that are already abstracted by workspace packages.

#### ‚ùå **NEVER DO THIS**:
```typescript
// In apps/web/package.json - DON'T add these if workspace packages exist
{
  "dependencies": {
    "@clerk/nextjs": "^6.20.0",     // ‚ùå Use @workspace/auth instead
    "drizzle-orm": "^0.36.0",       // ‚ùå Use @workspace/db instead  
    "lucide-react": "^0.475.0",     // ‚ùå Use @workspace/ui instead
    "@radix-ui/react-*": "*"        // ‚ùå Use @workspace/ui instead
  }
}

// In app code - DON'T import external deps directly
import { SignIn } from "@clerk/nextjs";           // ‚ùå Bypasses abstraction
import { clerkMiddleware } from "@clerk/nextjs/server"; // ‚ùå Bypasses abstraction
import { db } from "drizzle-orm";                 // ‚ùå Bypasses abstraction
import { Button } from "@radix-ui/react-button";  // ‚ùå Bypasses abstraction
```

#### ‚úÖ **ALWAYS DO THIS**:
```typescript
// In apps/web/package.json - ONLY workspace packages
{
  "dependencies": {
    "@workspace/auth": "workspace:*",     // ‚úÖ Use workspace abstraction
    "@workspace/db": "workspace:*",       // ‚úÖ Use workspace abstraction
    "@workspace/ui": "workspace:*"        // ‚úÖ Use workspace abstraction
  }
}

// In app code - ONLY import from workspace packages
import { SignIn, SSOCallback } from "@workspace/auth/components";    // ‚úÖ Clean abstraction
import { authMiddleware } from "@workspace/auth/middleware";          // ‚úÖ Clean abstraction  
import { db, users } from "@workspace/db";                          // ‚úÖ Clean abstraction
import { Button } from "@workspace/ui/components";                   // ‚úÖ Clean abstraction
```

### **Architecture Decision Framework**

**BEFORE implementing ANY solution, ask:**

1. **Does a workspace package already handle this concern?**
   - If YES ‚Üí Use the workspace package, extend it if needed
   - If NO ‚Üí Consider if this should be a new workspace package

2. **Is this a cross-cutting concern?**
   - Authentication ‚Üí `@workspace/auth`
   - Database ‚Üí `@workspace/db` 
   - UI Components ‚Üí `@workspace/ui`
   - Shared utilities ‚Üí Create new workspace package

3. **Will multiple apps need this functionality?**
   - If YES ‚Üí Must be in a workspace package
   - If NO ‚Üí Can be app-specific, but still prefer workspace packages

### **Workspace Package Responsibilities**

#### @workspace/auth
- **Purpose**: Complete authentication abstraction layer
- **Exports**: All auth components, hooks, middleware, server utilities
- **Internal deps**: `@clerk/nextjs`, `@clerk/themes`, etc.
- **Apps should NEVER**: Import from `@clerk/*` directly

```typescript
// ‚úÖ @workspace/auth should export everything apps need
export { SignIn, SignUp, SSOCallback } from "./components";
export { authMiddleware, createRouteMatcher } from "./middleware";  
export { auth, currentUser } from "./server";
export { useAuth, useUser } from "./client";
```

#### @workspace/db  
- **Purpose**: Complete database abstraction layer
- **Exports**: Connection, schemas, operations, migrations
- **Internal deps**: `drizzle-orm`, `@types/pg`, etc.
- **Apps should NEVER**: Import from `drizzle-orm` or database drivers directly

```typescript
// ‚úÖ @workspace/db should export everything apps need
export { db } from "./connection";
export * from "./schema";
export * from "./operations";  
export * from "./types";
```

#### @workspace/ui
- **Purpose**: Complete UI component system
- **Exports**: All reusable components, styles, utilities
- **Internal deps**: `@radix-ui/*`, `class-variance-authority`, etc.
- **Apps should NEVER**: Import from `@radix-ui/*` or other UI libraries directly

```typescript
// ‚úÖ @workspace/ui should export everything apps need
export { Button, Input, Card, Dialog, Alert } from "./components";
export { cn } from "./utils";
export "./globals.css";
```

### **Dependency Management Rules**

#### **For Apps (apps/web/)**:
```json
{
  "dependencies": {
    // ‚úÖ ONLY these types of dependencies allowed:
    "@workspace/*": "workspace:*",        // Workspace packages
    "next": "^15.4.5",                   // Core framework  
    "react": "^19.1.1",                  // Core framework
    "react-dom": "^19.1.1"               // Core framework
    
    // ‚ùå NEVER add these if workspace packages exist:
    // "@clerk/nextjs", "@radix-ui/*", "drizzle-orm", etc.
  }
}
```

#### **For Workspace Packages (packages/*/)**:
```json
{
  "dependencies": {
    // ‚úÖ External dependencies that the package abstracts
    "@clerk/nextjs": "^6.20.0",          // For @workspace/auth
    "drizzle-orm": "^0.36.0",            // For @workspace/db
    "@radix-ui/react-button": "^1.0.0"   // For @workspace/ui
  }
}
```

### **Problem-Solving Approach**

#### **When encountering missing functionality:**

1. **First**: Check if workspace package already provides it
2. **Second**: Extend the workspace package to provide it  
3. **Last Resort**: Add to app only if truly app-specific

#### **Example: Need Clerk SSO callback**

‚ùå **Wrong approach** (what happened before):
```typescript
// 1. Install @clerk/nextjs in web app
// 2. Import directly: import { AuthenticateWithRedirectCallback } from '@clerk/nextjs'
```

‚úÖ **Correct approach** (architectural solution):
```typescript  
// 1. Extend @workspace/auth package
export function SSOCallback() {
  return <AuthenticateWithRedirectCallback />;
}

// 2. Use from workspace package in app
import { SSOCallback } from "@workspace/auth/components";
```

### **Benefits of This Architecture**

1. **Single Source of Truth**: Each concern handled by one package
2. **Easy Refactoring**: Change implementation without touching apps
3. **Consistent APIs**: Same interface across all apps
4. **Better Testing**: Mock workspace packages instead of external deps
5. **Easier Upgrades**: Update external deps in one place
6. **Clear Boundaries**: Each package has well-defined responsibilities

### **Red Flags - Stop and Reconsider**

üö® **If you see any of these patterns, STOP and refactor**:

- Apps importing from external libraries that workspace packages should handle
- Duplicate external dependencies across apps and workspace packages
- Apps bypassing workspace package abstractions
- Inconsistent APIs for the same functionality across apps
- External dependencies scattered across multiple packages

### **Enforcement Rules**

- **Code Reviews**: Must check dependency usage in apps
- **Package.json Audits**: Apps should have minimal external dependencies  
- **Import Linting**: Configure to prevent direct external imports
- **Documentation**: Keep this architecture guide updated

## **MANDATORY: Architecture-First Problem Solving**

### **Before Writing ANY Code, Follow This Process:**

#### **Step 1: Understand the Architecture**
```
1. Which workspace packages exist?
2. What does each package handle?
3. Where should this functionality live?
4. Will this be reused across apps?
```

#### **Step 2: Check Existing Abstractions**
```
1. Does @workspace/auth already handle this auth concern?
2. Does @workspace/db already handle this data concern?  
3. Does @workspace/ui already handle this UI concern?
4. If not, should it be extended to handle it?
```

#### **Step 3: Choose the Right Solution**
```
‚úÖ Extend existing workspace package (preferred)
‚úÖ Create new workspace package (if cross-cutting)
‚ö†Ô∏è  Add to app (only if truly app-specific)
‚ùå Install external dependency in app (never if workspace package exists)
```

### **Problem-Solving Examples**

#### **Scenario: Need OAuth/SSO Authentication**

‚ùå **Hacky Approach** (what NOT to do):
```bash
# 1. Install external dependency directly in app
pnpm add @clerk/nextjs

# 2. Import directly in app code
import { AuthenticateWithRedirectCallback } from '@clerk/nextjs'
```

‚úÖ **Architectural Approach** (what TO do):
```bash
# 1. Check: Does @workspace/auth exist? YES
# 2. Check: Does it handle SSO? NO
# 3. Solution: Extend @workspace/auth to handle SSO

# In packages/auth/components/sso-callback.tsx
export function SSOCallback() {
  return <AuthenticateWithRedirectCallback />;
}

# In apps/web - use the abstraction
import { SSOCallback } from "@workspace/auth/components";
```

#### **Scenario: Need Database Operations**

‚ùå **Hacky Approach**:
```typescript
// Install drizzle-orm in app and use directly
import { drizzle } from 'drizzle-orm/postgres-js';
const db = drizzle(connectionString);
```

‚úÖ **Architectural Approach**:
```typescript
// Use existing @workspace/db abstraction
import { db, users } from "@workspace/db";
const user = await db.select().from(users);
```

#### **Scenario: Need New UI Component**

‚ùå **Hacky Approach**:
```typescript
// Install UI library directly in app
import { Dialog } from '@radix-ui/react-dialog';
```

‚úÖ **Architectural Approach**:
```typescript
// Check @workspace/ui first, extend if needed
import { Dialog } from "@workspace/ui/components";
```

### **Decision Tree for Dependencies**

```
Need functionality?
‚îú‚îÄ‚îÄ Is it authentication-related?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Check @workspace/auth first
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Exists ‚Üí Use it
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Missing ‚Üí Extend @workspace/auth
‚îÇ   ‚îî‚îÄ‚îÄ NO ‚Üí Continue
‚îú‚îÄ‚îÄ Is it database-related?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Check @workspace/db first  
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Exists ‚Üí Use it
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Missing ‚Üí Extend @workspace/db
‚îÇ   ‚îî‚îÄ‚îÄ NO ‚Üí Continue
‚îú‚îÄ‚îÄ Is it UI-related?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Check @workspace/ui first
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Exists ‚Üí Use it  
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Missing ‚Üí Extend @workspace/ui
‚îÇ   ‚îî‚îÄ‚îÄ NO ‚Üí Continue
‚îú‚îÄ‚îÄ Is it shared across apps?
‚îÇ   ‚îú‚îÄ‚îÄ YES ‚Üí Create new workspace package
‚îÇ   ‚îî‚îÄ‚îÄ NO ‚Üí Add to specific app (rare)
```

### **Quality Gates**

**Before submitting any code, verify:**

‚úÖ **Architecture Compliance**:
- [ ] No direct external dependencies in apps that bypass workspace packages
- [ ] All cross-cutting concerns handled by appropriate workspace packages
- [ ] Consistent API patterns across workspace packages
- [ ] Clean separation of concerns

‚úÖ **Dependency Hygiene**:
- [ ] Apps have minimal external dependencies
- [ ] Workspace packages properly abstract external dependencies  
- [ ] No duplicate dependencies across packages
- [ ] All imports go through workspace package abstractions

‚úÖ **Future-Proofing**:
- [ ] Solution is extensible and maintainable
- [ ] External dependencies can be swapped without touching apps
- [ ] API is consistent with existing workspace package patterns
- [ ] Documentation is updated to reflect changes

### **Common Anti-Patterns to Avoid**

üö® **Stop immediately if you find yourself doing any of these**:

1. **Dependency Bypass**: Installing external deps in apps when workspace packages exist
2. **Quick Fixes**: Adding functionality directly to apps instead of workspace packages  
3. **Inconsistent APIs**: Different patterns for the same type of functionality
4. **Tight Coupling**: Apps knowing about external dependency implementation details
5. **Scattered Logic**: Same concern handled in multiple places

### **Refactoring Checklist**

**When you encounter architectural violations**:

1. **Identify the Violation**:
   - What external dependency is being used directly?
   - Which workspace package should handle this concern?

2. **Plan the Fix**:
   - How can the workspace package be extended?
   - What API should it expose?
   - How will this affect existing code?

3. **Implement Properly**:
   - Add functionality to appropriate workspace package
   - Update app code to use workspace package
   - Remove direct external dependency from app
   - Test that abstraction works correctly

4. **Verify the Solution**:
   - Apps no longer import external dependencies directly
   - Functionality is properly abstracted
   - API is consistent with existing patterns
   - Documentation is updated

## Package Usage Guidelines

### @workspace/db

**When to use**: For all database operations and schema definitions

```typescript
// ‚úÖ Database connections
import { db } from "@workspace/db/connection";
import { users } from "@workspace/db/schema";

// ‚úÖ Queries with Drizzle
const user = await db.select().from(users).where(eq(users.id, userId));

// ‚úÖ Schema definitions
import { pgTable, text, timestamp } from "drizzle-orm/pg-core";

// ‚ùå Don't create direct SQL connections
// ‚ùå Don't bypass Drizzle ORM for queries
// ‚ùå Don't define schemas outside of @workspace/db
```

### @workspace/ui

**When to use**: For ALL UI components - **ALWAYS use existing components from @workspace/ui**

**CRITICAL RULE**: **NEVER create custom HTML elements or components when @workspace/ui has an equivalent**

#### Available UI Components

The following components are available in `@workspace/ui` and **MUST be used instead of creating custom alternatives**:

##### Form Components
```typescript
// ‚úÖ ALWAYS use these for forms
import { 
  Button,           // All button interactions
  Input,            // Text inputs, email, password, etc.
  Label,            // Form labels with required indicators
  Checkbox,         // Checkboxes with labels
  FormField,        // Complete field with label, input, and error
} from "@workspace/ui/components";

// ‚úÖ Form field with validation
<FormField
  label="Email"
  required
  error={errors.email}
  inputProps={{
    type: "email",
    value: formData.email,
    onChange: handleChange,
    placeholder: "user@example.com"
  }}
/>

// ‚úÖ Individual components
<Label htmlFor="email" required>Email</Label>
<Input 
  id="email" 
  type="email" 
  error={!!errors.email}
  value={email}
  onChange={handleChange}
/>
<Checkbox 
  checked={rememberMe}
  onChange={handleChange}
  label="Remember me"
/>

// ‚ùå NEVER do this - use FormField or Input instead
<input type="email" className="border rounded px-3 py-2" />
<label className="font-medium">Email</label>
```

##### Layout Components
```typescript
// ‚úÖ ALWAYS use these for content layout
import { 
  Card,             // Content containers
  CardHeader,       // Card headers
  CardTitle,        // Card titles
  CardDescription,  // Card descriptions
  CardContent,      // Card body content
  CardFooter,       // Card footers
} from "@workspace/ui/components";

// ‚úÖ Structured card layout
<Card>
  <CardHeader>
    <CardTitle>User Profile</CardTitle>
    <CardDescription>Manage your account settings</CardDescription>
  </CardHeader>
  <CardContent>
    {/* main content */}
  </CardContent>
  <CardFooter>
    <Button>Save Changes</Button>
  </CardFooter>
</Card>

// ‚ùå NEVER do this - use Card components instead
<div className="border rounded-lg p-4">
  <h3 className="font-semibold text-lg">Title</h3>
  <div className="p-6">{/* content */}</div>
</div>
```

##### Feedback Components
```typescript
// ‚úÖ ALWAYS use these for user feedback
import { 
  Alert,            // Messages and notifications
  AlertTitle,       // Alert titles
  AlertDescription, // Alert content
} from "@workspace/ui/components";

// ‚úÖ Error messages
<Alert variant="destructive">
  <AlertDescription>
    Please fix the following errors before continuing.
  </AlertDescription>
</Alert>

// ‚úÖ Success messages
<Alert variant="success">
  <AlertTitle>Success!</AlertTitle>
  <AlertDescription>Your changes have been saved.</AlertDescription>
</Alert>

// ‚ùå NEVER do this - use Alert components instead
<div className="bg-red-50 border border-red-200 rounded p-4">
  <p className="text-red-700">Error message</p>
</div>
```

##### Modal Components
```typescript
// ‚úÖ ALWAYS use these for modals and dialogs
import { 
  Dialog,           // Modal container
  DialogHeader,     // Modal header
  DialogTitle,      // Modal title
  DialogContent,    // Modal body
  DialogFooter,     // Modal footer
  DialogClose,      // Close button
} from "@workspace/ui/components";

// ‚úÖ Modal structure
<Dialog open={showModal} onClose={setShowModal}>
  <DialogHeader>
    <DialogTitle>Confirm Action</DialogTitle>
    <DialogClose onClose={() => setShowModal(false)} />
  </DialogHeader>
  <DialogContent>
    <p>Are you sure you want to proceed?</p>
  </DialogContent>
  <DialogFooter>
    <Button variant="outline" onClick={() => setShowModal(false)}>
      Cancel
    </Button>
    <Button onClick={handleConfirm}>
      Confirm
    </Button>
  </DialogFooter>
</Dialog>

// ‚ùå NEVER do this - use Dialog components instead
<div className="fixed inset-0 bg-black bg-opacity-50">
  <div className="bg-white rounded-lg p-6">
    {/* modal content */}
  </div>
</div>
```

#### Component Usage Rules

**MANDATORY RULES**:

1. **ALWAYS import from @workspace/ui first** - Check available components before creating anything
2. **NEVER create custom HTML elements** when UI components exist:
   - ‚ùå `<button>` ‚Üí ‚úÖ `<Button>`
   - ‚ùå `<input>` ‚Üí ‚úÖ `<Input>` or `<FormField>`
   - ‚ùå `<div className="card">` ‚Üí ‚úÖ `<Card>`
   - ‚ùå Custom modals ‚Üí ‚úÖ `<Dialog>`
   - ‚ùå Custom alerts ‚Üí ‚úÖ `<Alert>`

3. **Use component variants** instead of custom styling:
```typescript
// ‚úÖ Use built-in variants
<Button variant="destructive" size="sm">Delete</Button>
<Alert variant="warning">Warning message</Alert>
<Card variant="elevated">Content</Card>

// ‚ùå Don't override with custom classes
<Button className="bg-red-600 text-white">Delete</Button>
```

4. **Import the global CSS** in your app root:
```typescript
// ‚úÖ Required in app layout
import "@workspace/ui/globals.css";
```

#### Component Decision Framework

**BEFORE creating ANY component**:

1. ‚úÖ **Check @workspace/ui components first** - Use existing if available
2. ‚úÖ **App-specific components** stay in the app ONLY if they contain:
   - Business logic specific to that app
   - App-specific data fetching
   - Highly customized behavior that won't be reused
3. ‚úÖ **Move to @workspace/ui** only if the component is:
   - Truly reusable across multiple apps
   - Contains no app-specific logic
   - Follows the design system patterns
   - Has generic, configurable props

#### Complete Import Examples

```typescript
// ‚úÖ ALWAYS import UI components first
import { 
  // Form components
  Button, Input, Label, Checkbox, FormField,
  // Layout components  
  Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter,
  // Feedback components
  Alert, AlertTitle, AlertDescription,
  // Modal components
  Dialog, DialogHeader, DialogTitle, DialogContent, DialogFooter, DialogClose,
} from "@workspace/ui/components";

// ‚úÖ Import global styles
import "@workspace/ui/globals.css";

// ‚úÖ Example usage in a form
export function ContactForm() {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Contact Us</CardTitle>
        <CardDescription>Send us a message</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <FormField
          label="Name"
          required
          inputProps={{
            value: name,
            onChange: (e) => setName(e.target.value),
          }}
        />
        <FormField
          label="Email"
          required
          error={errors.email}
          inputProps={{
            type: "email",
            value: email,
            onChange: (e) => setEmail(e.target.value),
          }}
        />
        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
      </CardContent>
      <CardFooter>
        <Button type="submit" disabled={isLoading}>
          {isLoading ? "Sending..." : "Send Message"}
        </Button>
      </CardFooter>
    </Card>
  );
}

// ‚ùå NEVER do this - recreating existing UI components
export function CustomButton({ children, onClick }) {
  return (
    <button 
      className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
      onClick={onClick}
    >
      {children}
    </button>
  );
}
```

## Next.js Best Practices

### App Router Structure

```typescript
// ‚úÖ Use App Router conventions
app/
‚îú‚îÄ‚îÄ layout.tsx          # Root layout
‚îú‚îÄ‚îÄ page.tsx           # Home page
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îî‚îÄ‚îÄ [...all]/
‚îÇ           ‚îî‚îÄ‚îÄ route.ts # Better Auth API routes
‚îú‚îÄ‚îÄ (auth)/
‚îÇ   ‚îú‚îÄ‚îÄ sign-in/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îî‚îÄ‚îÄ sign-up/
‚îÇ       ‚îî‚îÄ‚îÄ page.tsx
‚îî‚îÄ‚îÄ dashboard/
    ‚îú‚îÄ‚îÄ layout.tsx     # Nested layout
    ‚îî‚îÄ‚îÄ page.tsx
```

### Server Components & Client Components

```typescript
// ‚úÖ Server Component (default)
import { db } from "@workspace/db/connection";
import { users } from "@workspace/db/schema";

export default async function UsersPage() {
  const usersList = await db.select().from(users);
  return <UsersList users={usersList} />;
}

// ‚úÖ Client Component (when needed)
"use client";
import { useState } from "react";

export function InteractiveComponent() {
  const { user } = useAuth();
  const [count, setCount] = useState(0);
  // ... interactive logic
}

// ‚ùå Don't use "use client" unnecessarily
// ‚ùå Don't fetch data in client components when server components can do it
```

### Data Fetching

```typescript
// ‚úÖ Server-side data fetching
export default async function Page() {
  const data = await db.select().from(users);
  return <div>{/* render data */}</div>;
}

// ‚úÖ Client-side data fetching with SWR/React Query
"use client";
import useSWR from "swr";

export function ClientDataComponent() {
  const { data, error } = useSWR("/api/users", fetcher);
  if (error) return <div>Error: {error.message}</div>;
  if (!data) return <div>Loading...</div>;
  return <div>{/* render data */}</div>;
}

// ‚ùå Don't use useEffect for data fetching when better alternatives exist
// ‚ùå Don't mix server and client data fetching unnecessarily
```

### @workspace/auth

**When to use**: For all authentication-related functionality

This package provides Clerk authentication integration with a clean, consistent API.

```typescript
// ‚úÖ Server-side auth
import { auth, currentUser } from "@workspace/auth/server";

// ‚úÖ Client-side auth hooks and components
import { useUser, SignedIn, SignedOut, UserButton } from "@workspace/auth/client";
import { SignIn, SignUp } from "@workspace/auth/components";

// ‚úÖ Provider setup
import { AuthProvider } from "@workspace/auth/provider";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <AuthProvider>{children}</AuthProvider>
      </body>
    </html>
  );
}

// ‚úÖ Middleware setup
import { authMiddleware } from "@workspace/auth/middleware";

export default authMiddleware({
  publicRoutes: ["/", "/api/health"],
});

// ‚ùå Don't implement auth from scratch
// ‚ùå Don't use multiple auth libraries simultaneously
```

## Database & Drizzle Best Practices

### Schema Design

```typescript
// ‚úÖ Define schemas in @workspace/db/src/schema/
import { pgTable, text, timestamp, boolean, varchar } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: varchar("id", { length: 36 }).primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  name: text("name").notNull(),
  emailVerified: boolean("email_verified").default(false).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

// ‚úÖ Export types
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
```

### Database Operations

```typescript
// ‚úÖ Use Drizzle query builder
import { db } from "@workspace/db/connection";
import { users } from "@workspace/db/schema";
import { eq, and, or, desc } from "drizzle-orm";

// Select with conditions
const user = await db
  .select()
  .from(users)
  .where(eq(users.email, email))
  .limit(1);

// Insert with returning
const [newUser] = await db
  .insert(users)
  .values({ email, name })
  .returning();

// Update with conditions
await db
  .update(users)
  .set({ name: newName, updatedAt: new Date() })
  .where(eq(users.id, userId));

// Complex queries with joins
const result = await db
  .select({
    user: users,
    sessionCount: count(sessions.id),
  })
  .from(users)
  .leftJoin(sessions, eq(users.id, sessions.userId))
  .groupBy(users.id);

// ‚ùå Don't write raw SQL unless absolutely necessary
// ‚ùå Don't use string concatenation for queries
```

### Migrations

```typescript
// ‚úÖ Generate migrations
// pnpm --filter @workspace/db generate

// ‚úÖ Run migrations
// pnpm --filter @workspace/db migrate

// ‚úÖ Migration files are auto-generated in drizzle/migrations/
// ‚ùå Don't edit migration files manually
// ‚ùå Don't skip the generation step
```

### Connection Management

```typescript
// ‚úÖ Use singleton connection from @workspace/db
import { db } from "@workspace/db/connection";

// ‚úÖ Connection pooling is handled automatically
// ‚ùå Don't create multiple database connections
// ‚ùå Don't manage connections manually
```

## Tailwind CSS Best Practices

### Configuration

```typescript
// ‚úÖ Use Tailwind CSS 4 configuration
// tailwind.config.ts
import type { Config } from "tailwindcss";

export default {
  content: [
    "./src/**/*.{js,ts,jsx,tsx}",
    "../packages/ui/src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: "#f0f9ff",
          500: "#3b82f6",
          900: "#1e3a8a",
        },
      },
    },
  },
  plugins: [],
} satisfies Config;
```

### Component Styling

**CRITICAL**: **NEVER create custom styled components** - Always use `@workspace/ui` components

```typescript
// ‚úÖ ALWAYS use existing @workspace/ui components
import { Button, Card } from "@workspace/ui/components";

// ‚úÖ Use built-in variants and props
<Button variant="primary" size="lg">Primary Action</Button>
<Button variant="secondary" size="sm">Secondary Action</Button>
<Button variant="destructive">Delete</Button>

<Card variant="elevated" className="max-w-md">
  <CardContent>Content here</CardContent>
</Card>

// ‚úÖ Extend with additional Tailwind classes if needed
<Button variant="primary" className="w-full mt-4">
  Full Width Button
</Button>

// ‚úÖ Use clsx/cn for conditional styling on containers only
import { cn } from "@workspace/ui/lib/utils";

export function AppSpecificContainer({ isActive, className, children }) {
  return (
    <div
      className={cn(
        "container mx-auto", // base layout classes
        isActive && "border-primary", // conditional styling
        className
      )}
    >
      {children}
    </div>
  );
}

// ‚ùå NEVER create custom Button components - use @workspace/ui Button
export function CustomButton({ variant = "primary", size = "md", children, ...props }) {
  const baseClasses = "font-medium rounded-lg focus:outline-none focus:ring-2";
  // ... DON'T DO THIS
}

// ‚ùå NEVER create custom Card components - use @workspace/ui Card
export function CustomCard({ variant, isActive, className, children }) {
  return (
    <div className={clsx("rounded-lg border p-4", /* ... */)}>
      {children}
    </div>
  );
}

// ‚ùå NEVER use CSS-in-JS libraries
// ‚ùå Don't use styled-components, emotion, or similar
// ‚ùå Don't use tailwind-variants or other CSS-in-JS solutions
// ‚ùå Don't recreate components that exist in @workspace/ui
```

### When to Create Custom Components

**ONLY create custom components for**:

1. **App-specific business logic containers**:
```typescript
// ‚úÖ This contains app-specific logic, not UI styling
export function UserDashboard({ userId }: { userId: string }) {
  const { user } = useAuth(); // app-specific logic
  const { data } = useSWR(`/api/users/${userId}`); // app-specific data
  
  return (
    <Card> {/* Use UI component for styling */}
      <CardHeader>
        <CardTitle>Welcome, {user?.name}</CardTitle>
      </CardHeader>
      <CardContent>
        {/* App-specific content */}
        <UserStats data={data} />
        <RecentActivity userId={userId} />
      </CardContent>
    </Card>
  );
}
```

2. **Layout containers with no styling logic**:
```typescript
// ‚úÖ Pure layout logic, uses UI components for actual styling
export function DashboardLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen bg-background">
      <header className="border-b">
        <AuthNav /> {/* Uses UI components internally */}
      </header>
      <main className="container mx-auto py-6">
        {children}
      </main>
    </div>
  );
}
```

### Responsive Design

```typescript
// ‚úÖ Mobile-first responsive design
<div className="
  flex flex-col          /* Mobile: stack vertically */
  md:flex-row           /* Tablet+: side by side */
  lg:gap-8              /* Desktop: larger gap */
  xl:max-w-6xl          /* Large screens: max width */
">
  <div className="w-full md:w-1/3 lg:w-1/4">Sidebar</div>
  <div className="w-full md:w-2/3 lg:w-3/4">Content</div>
</div>

// ‚ùå Don't use desktop-first breakpoints
// ‚ùå NEVER use CSS-in-JS or traditional CSS
// ‚ùå Don't mix Tailwind with other styling solutions
```

## TypeScript Best Practices

### Type Definitions

```typescript
// ‚úÖ Use strict TypeScript configuration
// tsconfig.json extends @workspace/typescript-config

// ‚úÖ Define proper types
export type User = {
  id: string;
  email: string;
  name: string;
  emailVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
};

// ‚úÖ Use utility types
export type CreateUserData = Omit<User, "id" | "createdAt" | "updatedAt">;
export type UpdateUserData = Partial<Pick<User, "name" | "email">>;

// ‚úÖ Generic types for reusability
export type ApiResponse<T> = {
  success: boolean;
  data?: T;
  error?: string;
};

// ‚ùå Don't use `any` type
// ‚ùå Don't use `unknown` unless specifically needed
```

### Component Props

```typescript
// ‚úÖ Define component prop types
export type ButtonProps = {
  variant?: "primary" | "secondary" | "danger";
  size?: "sm" | "md" | "lg";
  disabled?: boolean;
  children: React.ReactNode;
} & React.ButtonHTMLAttributes<HTMLButtonElement>;

export function Button({ variant = "primary", size = "md", children, ...props }: ButtonProps) {
  return <button {...props}>{children}</button>;
}

// ‚úÖ Use React.forwardRef with proper types
export const Input = React.forwardRef<
  HTMLInputElement,
  React.InputHTMLAttributes<HTMLInputElement>
>(({ className, ...props }, ref) => {
  return <input ref={ref} className={cn("base-input-styles", className)} {...props} />;
});
Input.displayName = "Input";
```

### API Types

```typescript
// ‚úÖ Define API route types
export type CreateUserRequest = {
  email: string;
  name: string;
  password: string;
};

export type CreateUserResponse = ApiResponse<{
  user: Omit<User, "password">;
  session: Session;
}>;

// ‚úÖ Type API routes
import type { NextRequest } from "next/server";

export async function POST(request: NextRequest) {
  const body: CreateUserRequest = await request.json();
  // ... handle request
  return Response.json({ success: true, data: user } satisfies CreateUserResponse);
}
```

## Error Handling Best Practices

### Client-Side Error Handling

```typescript
// ‚úÖ Comprehensive error handling with types
export type Result<T, E = Error> = {
  success: true;
  data: T;
} | {
  success: false;
  error: E;
};

export async function createUser(data: CreateUserData): Promise<Result<User>> {
  try {
    const response = await fetch("/api/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      const error = await response.json();
      return { success: false, error: new Error(error.message) };
    }

    const user = await response.json();
    return { success: true, data: user };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error : new Error("Unknown error") 
    };
  }
}

// ‚úÖ Use error boundaries
export function ErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundaryComponent
      fallback={<div>Something went wrong. Please try again.</div>}
    >
      {children}
    </ErrorBoundaryComponent>
  );
}
```

### Server-Side Error Handling

```typescript
// ‚úÖ API route error handling
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate input
    const validatedData = createUserSchema.parse(body);
    
    // Process request
    const user = await db.insert(users).values(validatedData).returning();
    
    return Response.json({ success: true, data: user[0] });
  } catch (error) {
    console.error("Create user error:", error);
    
    if (error instanceof z.ZodError) {
      return Response.json(
        { success: false, error: "Invalid input data", details: error.errors },
        { status: 400 }
      );
    }
    
    return Response.json(
      { success: false, error: "Internal server error" },
      { status: 500 }
    );
  }
}
```

## Performance Best Practices

### Next.js Optimization

```typescript
// ‚úÖ Use Next.js Image component
import Image from "next/image";

<Image
  src="/profile.jpg"
  alt="Profile picture"
  width={100}
  height={100}
  priority // for above-the-fold images
/>

// ‚úÖ Dynamic imports for code splitting
import dynamic from "next/dynamic";

const DynamicComponent = dynamic(() => import("./heavy-component"), {
  loading: () => <div>Loading...</div>,
});

// ‚úÖ Use React.memo for expensive components
export const ExpensiveComponent = React.memo(({ data }: { data: ComplexData }) => {
  const processedData = useMemo(() => processData(data), [data]);
  return <div>{/* render processed data */}</div>;
});
```

### Database Optimization

```typescript
// ‚úÖ Use indexes in schema
export const users = pgTable("users", {
  id: varchar("id", { length: 36 }).primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(), // Automatic index
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => ({
  emailIdx: index("email_idx").on(table.email), // Explicit index
  createdAtIdx: index("created_at_idx").on(table.createdAt),
}));

// ‚úÖ Optimize queries
// Use select specific fields
const users = await db
  .select({
    id: users.id,
    email: users.email,
    name: users.name,
  })
  .from(users)
  .limit(10);

// Use pagination
const users = await db
  .select()
  .from(users)
  .offset(page * pageSize)
  .limit(pageSize);
```

## Security Best Practices

### Authentication Security

```typescript
// ‚úÖ Environment variables
// .env.local
AUTH_SECRET=your-super-secret-key-here
DATABASE_URL=postgresql://user:password@localhost:5432/database
TRUSTED_ORIGINS=https://yourdomain.com

// ‚úÖ CSRF protection (handled by Better Auth)
// ‚úÖ Session security (handled by Better Auth)
// ‚úÖ Rate limiting (handled by Better Auth)

// ‚ùå Don't hardcode secrets
// ‚ùå Don't expose sensitive data in client-side code
```

### Input Validation

```typescript
// ‚úÖ Use Zod for validation
import { z } from "zod";

export const createUserSchema = z.object({
  email: z.string().email("Invalid email format"),
  name: z.string().min(1, "Name is required").max(100, "Name too long"),
  password: z.string()
    .min(8, "Password must be at least 8 characters")
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, "Password must contain uppercase, lowercase, and number"),
});

// ‚úÖ Validate on both client and server
export async function POST(request: NextRequest) {
  const body = await request.json();
  const validatedData = createUserSchema.parse(body); // Throws on invalid data
  // ... process validated data
}
```

## Testing Best Practices

### Unit Testing

```typescript
// ‚úÖ Test utilities and hooks
import { renderHook, act } from "@testing-library/react";

// Example test for custom hooks
describe("useCustomHook", () => {
  it("should return expected state", async () => {
    const { result } = renderHook(() => useCustomHook());
    
    expect(result.current.isLoading).toBe(true);
    
    await act(async () => {
      // Wait for async operations
    });
    
    expect(result.current.data).toBeDefined();
  });
});
```

### Integration Testing

```typescript
// ‚úÖ Test API routes
import { POST } from "@/app/api/users/route";

describe("/api/users", () => {
  it("should create a user", async () => {
    const request = new Request("http://localhost:3000/api/users", {
      method: "POST",
      body: JSON.stringify({
        email: "test@example.com",
        name: "Test User",
        password: "SecurePassword123",
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.success).toBe(true);
    expect(data.data.email).toBe("test@example.com");
  });
});
```

## Development Workflow

### Commands

```bash
# Development
pnpm dev                    # Start all apps in development
pnpm build                  # Build all packages and apps
pnpm lint                   # Lint all code
pnpm format                 # Format all code with Biome
pnpm type-check            # Type check all packages

# Database
pnpm --filter @workspace/db generate  # Generate migrations
pnpm --filter @workspace/db migrate   # Run migrations
pnpm --filter @workspace/db studio    # Open Drizzle Studio

# Package-specific
pnpm --filter @workspace/db build     # Build db package
pnpm --filter web dev                 # Start web app only
```

### Git Workflow

```bash
# ‚úÖ Commit message format
feat(auth): add password reset functionality
fix(db): resolve connection pool issue
docs(readme): update installation instructions
refactor(ui): simplify button component API

# ‚úÖ Branch naming
feature/auth-password-reset
fix/db-connection-pool
refactor/ui-button-api
```

## Common Anti-Patterns to Avoid

### ‚ùå Don't Do These

```typescript
// ‚ùå NEVER create custom UI components when @workspace/ui has them
// DON'T create buttons
export function CustomButton({ children, onClick }) {
  return <button className="bg-blue-600 text-white px-4 py-2 rounded" onClick={onClick}>{children}</button>;
}

// DON'T create inputs
export function CustomInput({ value, onChange }) {
  return <input className="border rounded px-3 py-2" value={value} onChange={onChange} />;
}

// DON'T create cards
export function CustomCard({ children }) {
  return <div className="border rounded-lg p-4 shadow">{children}</div>;
}

// DON'T create modals
export function CustomModal({ isOpen, onClose, children }) {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50">
      <div className="bg-white rounded-lg p-6">{children}</div>
    </div>
  );
}

// DON'T create alerts
export function CustomAlert({ message, type }) {
  return <div className={`p-4 rounded ${type === 'error' ? 'bg-red-100' : 'bg-blue-100'}`}>{message}</div>;
}

// ‚ùå Don't use raw HTML elements when UI components exist
<button onClick={handleClick}>Click me</button>           // Use <Button>
<input type="email" value={email} onChange={setEmail} />  // Use <Input> or <FormField>
<div className="border rounded p-4">Content</div>         // Use <Card>

// ‚ùå Don't bypass the auth package
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";

// ‚ùå Don't create direct database connections
import { Pool } from "pg";
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

// ‚ùå Don't use inline styles instead of Tailwind
<div style={{ padding: "16px", backgroundColor: "#f3f4f6" }}>

// ‚ùå NEVER use CSS-in-JS libraries
import styled from "styled-components";
import { css } from "@emotion/react";
import { tv } from "tailwind-variants";

const StyledButton = styled.button`
  padding: 16px;
  background-color: blue;
`;

// ‚ùå Don't use traditional CSS files
import "./component.css";
import styles from "./component.module.css";

// ‚ùå Don't ignore TypeScript errors
// @ts-ignore
const user = getData().user.profile.name;

// ‚ùå Don't use any type
function processData(data: any): any {
  return data.whatever;
}

// ‚ùå Don't implement multiple auth systems simultaneously
// Choose one authentication solution and stick with it
```

### ‚úÖ Do These Instead

```typescript
// ‚úÖ ALWAYS use @workspace/ui components
import { 
  Button, Input, FormField, Card, CardHeader, CardTitle, CardContent,
  Alert, AlertDescription, Dialog, DialogContent, Checkbox, Label
} from "@workspace/ui/components";

// ‚úÖ Use UI components for all interactions
<Button variant="primary" onClick={handleClick}>Click me</Button>
<Input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
<FormField label="Email" required inputProps={{ type: "email", value: email, onChange: handleChange }} />

// ‚úÖ Use Card for content containers
<Card>
  <CardHeader>
    <CardTitle>User Profile</CardTitle>
  </CardHeader>
  <CardContent>
    <p>User information here</p>
  </CardContent>
</Card>

// ‚úÖ Use Alert for messages
<Alert variant="destructive">
  <AlertDescription>An error occurred</AlertDescription>
</Alert>

// ‚úÖ Use Dialog for modals
<Dialog open={isOpen} onClose={setIsOpen}>
  <DialogContent>
    <p>Modal content</p>
  </DialogContent>
</Dialog>

// ‚úÖ Use the auth package with @workspace/ui components
import { useUser, SignedIn, SignedOut } from "@workspace/auth/client";
import { AuthProvider } from "@workspace/auth/provider";

// ‚úÖ Use the database package
import { db } from "@workspace/db/connection";
import { users } from "@workspace/db/schema";

// ‚úÖ Use Tailwind classes for layout only (not component styling)
<div className="container mx-auto p-4 bg-background">

// ‚úÖ Use cn/clsx for conditional layout classes only
import { cn } from "@workspace/ui/lib/utils";
<div className={cn("container mx-auto", isActive && "border-primary", className)}>

// ‚úÖ Handle TypeScript errors properly
const user = getData()?.user?.profile?.name ?? "Unknown";

// ‚úÖ Use proper types
function processData(data: UserData): ProcessedData {
  return { name: data.name, email: data.email };
}
```

## üö® CRITICAL: shadcn/ui Design System & Color Guidelines

### **NEVER use random colors - ONLY semantic classes**

This project strictly follows shadcn/ui design system conventions. **ALL colors must use semantic CSS variables and their corresponding Tailwind classes.**

#### Semantic Color System

**‚úÖ ALWAYS use these semantic color classes:**

```typescript
// Background colors
"bg-background"           // Main background
"bg-card"                // Card backgrounds  
"bg-primary"             // Primary actions
"bg-secondary"           // Secondary actions
"bg-muted"               // Muted backgrounds
"bg-accent"              // Accent backgrounds
"bg-destructive"         // Destructive actions (errors, delete)

// Text colors
"text-foreground"        // Primary text
"text-muted-foreground"  // Secondary/muted text
"text-primary"           // Primary action text
"text-destructive"       // Error/destructive text

// Border colors
"border-border"          // Standard borders
"border-input"           // Input borders
"border-primary"         // Primary borders
"border-destructive"     // Error borders

// With opacity for subtle variations
"bg-primary/10"          // 10% opacity
"bg-destructive/5"       // 5% opacity
"border-destructive/20"  // 20% opacity border
```

**‚ùå NEVER use arbitrary color classes:**

```typescript
// ‚ùå WRONG: Random colors
"bg-blue-600"            // Use bg-primary instead
"bg-red-500"             // Use bg-destructive instead  
"bg-gray-100"            // Use bg-muted instead
"text-gray-500"          // Use text-muted-foreground instead
"border-red-400"         // Use border-destructive instead
```

#### State-Based Color Usage

**‚úÖ CORRECT semantic color patterns:**

```typescript
// Success states
"text-green-600 dark:text-green-400"
"bg-green-500/10"
"border-green-500/20"

// Warning states  
"text-yellow-600 dark:text-yellow-400"
"bg-yellow-500/10"
"border-yellow-500/20"

// Error states (prefer destructive)
"text-destructive"
"bg-destructive/10"
"border-destructive/20"

// Priority indicators
export const getPriorityColor = (priority: string) => {
  switch (priority) {
    case "high":
      return "bg-destructive/10 text-destructive border-destructive/20";
    case "medium":
      return "bg-yellow-500/10 text-yellow-700 border-yellow-500/20 dark:text-yellow-400";
    case "low":
      return "bg-green-500/10 text-green-700 border-green-500/20 dark:text-green-400";
    default:
      return "bg-muted text-muted-foreground border-border";
  }
};
```

#### Common Color Replacements

| ‚ùå Old Random Color | ‚úÖ New Semantic Color |
|-------------------|---------------------|
| `bg-gray-50` | `bg-background` or `bg-muted` |
| `bg-white` | `bg-background` or `bg-card` |
| `text-gray-900` | `text-foreground` |
| `text-gray-600` | `text-muted-foreground` |
| `border-gray-300` | `border-border` |
| `bg-blue-600` | `bg-primary` |
| `text-red-600` | `text-destructive` |
| `bg-red-50` | `bg-destructive/5` |

### **Enforcement Rules**

**üö® Code Review Checklist:**
- [ ] **NO arbitrary color classes** (bg-blue-600, text-red-500, etc.)
- [ ] **ALL colors use semantic classes** (bg-primary, text-destructive, etc.)
- [ ] **State colors use semantic meanings** (success, warning, error)
- [ ] **Dark mode handled automatically** or explicitly for semantic colors only
- [ ] **Hover states use semantic variations** (/90, /80, etc.)

**üö® Linting Pattern to Catch:**
```regex
/(bg-|text-|border-)(red|blue|green|yellow|orange|purple|pink|indigo|gray|slate|zinc|neutral|stone)-\d+/
```

## Summary Checklist

Before submitting code, ensure:

**UI Components (CRITICAL)**:
- [ ] **NEVER created custom buttons, inputs, cards, modals, or alerts** - Always use @workspace/ui
- [ ] **All interactive elements use @workspace/ui components**: Button, Input, FormField, etc.
- [ ] **All layout containers use @workspace/ui components**: Card, Dialog, Alert, etc.
- [ ] **Imported @workspace/ui/globals.css** in app root
- [ ] **Used component variants** instead of custom styling (variant="primary", size="lg", etc.)
- [ ] **Checked @workspace/ui components first** before creating any UI element

**shadcn/ui Design System (CRITICAL)**:
- [ ] **NO random colors** - Only semantic classes (bg-primary, text-destructive, etc.)
- [ ] **ALL colors follow shadcn/ui conventions** - Use design system variables
- [ ] **State colors are semantic** - green for success, yellow for warning, destructive for errors
- [ ] **Dark mode supported** - Semantic classes handle automatically
- [ ] **Opacity modifiers used** - /5, /10, /20 for subtle variations

**Package Usage**:
- [ ] Uses appropriate workspace packages (@workspace/auth, @workspace/db, @workspace/ui)
- [ ] Uses Clerk for authentication via @workspace/auth
- [ ] Uses Drizzle ORM for database operations
- [ ] **Never bypassed @workspace/ui** for UI components

**Code Quality**:
- [ ] Follows Next.js App Router conventions
- [ ] Uses Tailwind CSS classes ONLY for layout (no CSS-in-JS, no traditional CSS)
- [ ] **No custom styled components** - only @workspace/ui components
- [ ] **NEVER uses random colors** - only semantic shadcn/ui classes
- [ ] Has proper TypeScript types
- [ ] Includes error handling
- [ ] Follows security best practices
- [ ] Is properly tested
- [ ] Passes Biome linting and formatting
- [ ] Uses semantic commit messages

**REMEMBER**: 
1. **@workspace/ui components are MANDATORY** - Never create custom UI elements
2. **NEVER use random colors** - Always use semantic classes (bg-primary, text-destructive, etc.)
3. **Check @workspace/ui first** - It has Button, Input, Card, Dialog, Alert, FormField, Checkbox, Label, and more
4. **Think semantically** - What does this color represent? (primary, destructive, success, warning)
5. **Use variants and props** - Don't override with custom Tailwind classes
6. **Layout vs Components** - Use Tailwind for layout containers, @workspace/ui for interactive elements

Always prefer using the workspace packages over implementing functionality from scratch. They provide tested, consistent APIs that integrate well with the overall architecture.

**Color Philosophy**: Always ask "What semantic meaning does this color have?" instead of "What color looks good here?"